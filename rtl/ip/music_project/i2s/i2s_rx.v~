module i2s_rx
#(
    parameter DATA_WIDTH= 32     
)
(
    input reset_n,
    input bclk,
    input adclrc,
    input adcdat,   
    input adcfifo_rdclk,
    input adcfifo_read,
    input [7:0] rx_data,
    input rx_done,
    output cic_clk,
    output adcfifo_empty,
    output [DATA_WIDTH - 1:0] adcfifo_readdata 
);
 
parameter state_idle        = 2'd0;   //空闲状�??
parameter state_left_data   = 2'd1;   //采集左�?�道数据
parameter state_right_data  = 2'd2;   //采集右�?�道数据
parameter state_fifo_write  = 2'd3;   //FIFO的写数据状�??
parameter div_4 = 4;
parameter div_8 = 8;
parameter div_64 = 64;
parameter div_128 = 128;
parameter div_256 = 256;
parameter x_th = 16'b0000_0011_0000_0000;
parameter fuzz_xth = 16'b0000_1100_0000_0000;


reg [1:0] state;
reg [7:0] bit_cnt;      //位计�?
reg [DATA_WIDTH - 1:0] reg_wrfifo_data; //定义中间变量，存放adc处理后的数据
reg [DATA_WIDTH/2 - 1:0] reg_cic_data1; //定义中间变量，存放wrfifo的数据，为cic的输入口
reg [DATA_WIDTH/2 - 1:0] reg_cic_data2; 

reg adcfifo_write;    //FIFO的写使能信号
//�?测adclrc的下降沿，标志着采集数据左�?�道数据，上升沿标志采集右�?�道数据

reg adclrc_nege;
reg adclrc_pose;

reg adclrc_r0;
reg adclrc_r1;
reg adcdat_r0;
reg adcdat_r1;

reg [2:0] cnt_4;
reg [3:0] cnt_8;
reg [6:0] cnt_64;
reg [7:0] cnt_128;
reg [8:0] cnt_256;

reg clk_48k;
reg clk_96k;
reg clk_192k;
reg clk_1_536k;
reg clk_3_072M;
reg cic_clk;

always @(posedge bclk)
if (~reset_n) begin
    clk_48k <= 1'b0;
    cnt_256 <= 9'b0;
end
else begin
    if(cnt_256 == div_256/2 - 1) begin
        clk_48k <= ~clk_48k;
        cnt_256 <= 9'b0;
    end
    else begin
        cnt_256 <= cnt_256 + 1'b1;
    end
end

always @(posedge bclk)
if (~reset_n) begin
    clk_96k <= 1'b0;
    cnt_128 <= 8'b0;
end
else begin
    if(cnt_128 == div_128/2 - 1) begin
        clk_96k <= ~clk_96k;
        cnt_128 <= 8'b0;
    end
    else begin
        cnt_128 <= cnt_128 + 1'b1;
    end
end

always @(posedge bclk)
if (~reset_n) begin
    clk_192k <= 1'b0;
    cnt_64 <= 7'b0;
end
else begin
    if(cnt_64 == div_64/2 - 1) begin
        clk_192k <= ~clk_192k;
        cnt_64 <= 7'b0;
    end
    else begin
        cnt_64 <= cnt_64 + 1'b1;
    end
end

always @(posedge bclk)
if (~reset_n) begin
    clk_1_536k <= 1'b0;
    cnt_8 <= 3'b0;
end
else begin
    if(cnt_8== div_8/2 - 1) begin
        clk_1_536k <= ~clk_1_536k;
        cnt_8 <= 3'b0;
    end
    else begin
        cnt_8 <= cnt_8 + 1'b1;
    end
end

always @(posedge bclk)
if (~reset_n) begin
    clk_3_072M <= 1'b0;
    cnt_4 <= 3'b0;
end
else begin
    if(cnt_4 == div_4/2 - 1) begin
        clk_3_072M <= ~clk_3_072M;
        cnt_4 <= 3'b0;
    end
    else begin
        cnt_4 <= cnt_4 + 1'b1;
    end
end
    
always @(posedge bclk) begin
    adclrc_r0 <= adclrc;
    adclrc_r1 <= adclrc_r0;
    adcdat_r0 <= adcdat;
	 adcdat_r1 <= adcdat_r0;
end

always@(posedge bclk)
if(~reset_n) begin
	adclrc_nege <= 1'd0;
	adclrc_pose <= 1'd0;
end
else begin
	adclrc_nege <= adclrc_r1 & (!adclrc_r0);
	adclrc_pose <= (!adclrc_r1) & adclrc_r0;
end


always@(posedge bclk)
if(~reset_n)
begin
    state <= state_idle;
    bit_cnt <= 8'd0;
    reg_wrfifo_data <= 0;
    adcfifo_write <= 0;
    //adcfifo_writedata <= 0;
end
else begin
    case(state)
        state_idle:
        begin
            adcfifo_write <= 1'd0;
            if(adclrc_nege)
            begin
                bit_cnt <= DATA_WIDTH - 1;
                state <= state_left_data;
            end
        end

        state_left_data:
        begin
            if(bit_cnt == (DATA_WIDTH/2 - 1)) //左�?�道数据采集完成
            begin
                if(adclrc_pose)        //进入左�?�道采集数据
                begin
                    state <= state_right_data;
                end
            end
            else 
            begin
                bit_cnt <= bit_cnt - 1'd1;
                reg_wrfifo_data[bit_cnt] = adcdat_r1;
            end
        end

        state_right_data:
        begin
            if(bit_cnt == 5'd0)         //32位数据采集完�?
            begin
                reg_wrfifo_data[bit_cnt] = adcdat_r1;
                state <= state_fifo_write;
            end
            else begin
                bit_cnt <= bit_cnt - 1'd1;
                reg_wrfifo_data[bit_cnt] = adcdat_r1;
                state <= state_right_data;
            end
        end

        state_fifo_write:
        begin
            adcfifo_write <= 1'd1;
            reg_cic_data1 <= reg_wrfifo_data[31:16]; //向adcfifo中写入数�?
            reg_cic_data2 <= reg_wrfifo_data[15:0]; 
            state <= state_idle; //经过�?轮数据传输后重新回到空闲模式
        end

        default: state <= state_idle;

    endcase
end

reg [DATA_WIDTH - 1:0] adcfifo_writedata;    //写入FIFO中的数据
wire [DATA_WIDTH/2 - 1:0] adcfifo_writedata1;
wire [DATA_WIDTH/2 - 1:0] adcfifo_writedata2;
wire [DATA_WIDTH/2 - 1:0] cicleft_out;
wire [16:0] compleft_out;
wire [16:0] compright_out;
wire [15:0] halfleft_out;
wire [15:0] halfright_out;
wire [DATA_WIDTH/2 - 1:0] filterleft_out;
wire [DATA_WIDTH/2 - 1:0] filterright_out;

wire rx_done;
reg [7:0] data_str [4:0];
always@(posedge adcfifo_rdclk)
    if(rx_done)begin
        data_str[4] <=  rx_data;
        data_str[3] <=  data_str[4];
        data_str[2] <=  data_str[3];
        data_str[1] <=  data_str[2];
        data_str[0] <=  data_str[1];        
    end 
reg r_rx_done;
reg [3:0] mode_state;
//reg [2:0] rever_state;
reg [2:0] chorus_state;
//reg [1:0] echo_state;
reg [1:0] cic_state;
always@(posedge adcfifo_rdclk)
    r_rx_done <= rx_done;

reg led1;
reg led2;
reg led3;
reg led4;
reg [1:0] echo_MODE;

always @(posedge adcfifo_rdclk) begin
    if(r_rx_done)begin 
        if((data_str[0] == 8'hd1) && (data_str[1] == 8'h00) && (data_str[2] == 8'h00) && (data_str[3] == 8'h00) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd11;
        end
        if((data_str[0] == 8'hd1) && (data_str[1] == 8'h01) && (data_str[2] == 8'h00) && (data_str[3] == 8'h01) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd0;
            cic_state <= 2'd1;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h01) && (data_str[2] == 8'h00) && (data_str[3] == 8'h02) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd1;
            cic_state <= 2'd2;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h01) && (data_str[2] == 8'h00) && (data_str[3] == 8'h03) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd2;
            cic_state <= 2'd3;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h02) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd3;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h03) && (data_str[2] == 8'h00) && (data_str[3] == 8'h02) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd4;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h04) && (data_str[2] == 8'h00) && (data_str[3] == 8'h01) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd4;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h04) && (data_str[2] == 8'h00) && (data_str[3] == 8'h02) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd4;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h04) && (data_str[2] == 8'h00) && (data_str[3] == 8'h03) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd4;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h05) && (data_str[2] == 8'h00) && (data_str[3] == 8'h01) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd6;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h05) && (data_str[2] == 8'h00) && (data_str[3] == 8'h02) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd7;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h05) && (data_str[2] == 8'h00) && (data_str[3] == 8'h03) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd8;
        end
        else if((data_str[0] == 8'hd1) && (data_str[1] == 8'h05) && (data_str[2] == 8'h00) && (data_str[3] == 8'h04) && (data_str[4] == 8'hd2))begin
            mode_state <= 4'd9;
        end
    end
end

voice cic1(
    .clk_48k(clk_48k),
    .clk_96k(clk_96k),
    .clk_192k(clk_192k),
    .clk_3_072M(clk_3_072M),
    .rst_n(reset_n),
    .din_half(reg_cic_data1),
    .dout_cic(cicleft_out),
    .dout_comp(compleft_out),
    .dout_half(halfleft_out)
);

/*eq_filter left(
    .clk(adcfifo_rdclk),
    .bclk(clk_192k),
    .reset(reset_n),
    .filter_in(cicleft_out),
    .filter_out(filterleft_out),
    .rx_data(rx_data),
    .rx_done(rx_done)
);*/

eq_filter right(
    .clk(adcfifo_rdclk),
    .bclk(clk_192k),
    .reset(reset_n),
    .rx_data(rx_data),
    .rx_done(rx_done),
    .filter_in(reg_cic_data1),
    .filter_out(filterright_out)
);

wire [15:0] reverberator_out1;
wire [15:0] echosounders_out1;
reg [15:0] distortion_out;
wire [15:0] blues_out;
reg [15:0] override_out;
reg [15:0] fuzz_out;
wire [15:0] chorus_out;
//wire [15:0] filter_63_out;
wire [15:0] nonlinear_out;
wire [13:0] div4_din;
wire [17:0] triple_xth;
wire [15:0] triple_and_div4_xth; //值为�?
wire [15:0] abs_din;
assign div4_din = {{2{cicleft_out[15]}},cicleft_out[15:2]};
assign triple_xth = 3 * x_th;
assign triple_and_div4_xth = triple_xth >>> 2;
wire [15:0] abs_din;
wire [15:0] abs16_din;
assign abs_din = (cicleft_out[15]==1)? (~cicleft_out + 1'b1):cicleft_out;
assign abs16_din = abs_din <<< 4;

always @(*) begin
    case(cic_state)
        2'd1:cic_clk = clk_96k;
        2'd2:cic_clk = clk_192k;
        2'd3:cic_clk = clk_1_536k;
        default:cic_clk = clk_48k;
    endcase  
end

always @(*) begin
    if (abs_din > x_th) begin
        if (cicleft_out[15] == 1) begin
            override_out = -x_th;
        end
        else begin
            override_out = x_th;
        end
    end
    else begin
        override_out = cicleft_out;
    end
end

always @(*) begin
    if (abs16_din > fuzz_xth) begin
        if (cicleft_out[15] == 1) begin
            fuzz_out = -fuzz_xth;
        end
        else begin
            fuzz_out = fuzz_xth;
        end
    end
    else begin
        fuzz_out = cicleft_out;
    end
end

always @(*) begin
    if (abs_din > x_th) begin
        if (cicleft_out[15] == 1) begin
            distortion_out = {{2{1'b1}},cicleft_out[15:2]} - triple_and_div4_xth;
        end
        else begin
            distortion_out = {{2{1'b0}},cicleft_out[15:2]}  + triple_and_div4_xth;
        end
    end
    else begin
        distortion_out = cicleft_out;
    end
end

reg [1:0] MODE;
reg [1:0] dds_MODE;
reg [1:0] chorus_MODE;

/*chorus chorus_1(
	.clk(clk_48k),
	.rst_n(reset_n),
    .En(1'b1),
	.MODE(MODE),
    .chorus_MODE(chorus_MODE),
    .dds_MODE(dds_MODE),
	.din(cicleft_out),
	.dout(chorus_out)
);*/

blues blues(
    .clk(clk_48k),
    .reset_n(reset_n),
    .din(cicleft_out),
    .blues_out(blues_out)
);

/*wire [15:0] phaser_out1;
wire [15:0] phaser_out2;
phaser#(20)phaser(clk_48k,reset_n,1'b1,cicleft_out,phaser_out1);
phaser1#(190)phaser1(clk_48k,reset_n,1'b1,cicleft_out,phaser_out2);  */

                    
/*always @(*) begin
    case(rever_state)
        3'd1:rever_MODE <= 3'd1;
        3'd2:rever_MODE <= 3'd2;
        3'd0:rever_MODE <= 3'd0;
        3'd4:rever_MODE <= 3'd4;
        3'd6:rever_MODE <= 3'd6;
        3'd7:rever_MODE <= 3'd7;
        default:rever_MODE <= 2'd1;
    endcase
end*/

always @(*) begin   
    case(mode_state)
        4'd0:adcfifo_writedata = {halfleft_out,halfleft_out};
        4'd1:adcfifo_writedata = {compleft_out,compright_out};
        4'd2:adcfifo_writedata = {cicleft_out,cicleft_out};
        4'd3:adcfifo_writedata = {filterright_out,filterright_out};
        4'd6:adcfifo_writedata = {override_out,override_out};
        4'd7:adcfifo_writedata = {distortion_out,distortion_out};
        4'd8:adcfifo_writedata = {blues_out,blues_out};
        4'd9:adcfifo_writedata = {fuzz_out,fuzz_out};
        4'd11:adcfifo_writedata = {reg_cic_data1,reg_cic_data1};
        default:adcfifo_writedata = {reg_cic_data1,reg_cic_data1};
    endcase
end

async_fifo #(
	.DATA_WIDTH(DATA_WIDTH),
	.ADDR_WIDTH(8),
	.FULL_AHEAD(1),
	.SHOWAHEAD_EN(0)
)adc_fifo
(
	.reset(~reset_n),
	//fifo wr
	.wrclk(bclk),
	.wren(adcfifo_write),
	.wrdata(adcfifo_writedata),
	.full(adcfifo_full),
	.almost_full(),
	.wrusedw(),
	//fifo rd
	.rdclk(adcfifo_rdclk),
	.rden(adcfifo_read),
	.rddata(adcfifo_readdata),
	.empty(adcfifo_empty),
	.rdusedw()
);

endmodule